/**
 * TenderIntel - Export Service
 * Handles data export to CSV, Excel, and PDF formats
 * Version: 1.0.0
 * Last Updated: October 21, 2025
 */

class ExportService {
    constructor() {
        this.exportHistory = [];
        this.maxHistorySize = 20;
    }
    
    /**
     * Export data to CSV format
     * @param {Array} data - Array of objects to export
     * @param {string} filename - Filename without extension
     * @param {object} options - Export options
     * @returns {boolean} Success status
     */
    toCSV(data, filename = 'export', options = {}) {
        try {
            const csv = this.convertToCSV(data, options);
            this.downloadFile(csv, `${filename}.csv`, 'text/csv;charset=utf-8;');
            
            this.addToHistory('CSV', filename, data.length);
            return true;
            
        } catch (error) {
            console.error('CSV export failed:', error);
            return false;
        }
    }
    
    /**
     * Export data to Excel format
     * Falls back to CSV if XLSX library not available
     * @param {Array} data - Array of objects to export
     * @param {string} filename - Filename without extension
     * @param {object} options - Export options
     * @returns {boolean} Success status
     */
    toExcel(data, filename = 'export', options = {}) {
        try {
            // Check if XLSX library is loaded
            if (typeof XLSX !== 'undefined') {
                return this.toExcelWithXLSX(data, filename, options);
            } else {
                // Fallback to CSV with warning
                console.warn('XLSX library not loaded, falling back to CSV format');
                return this.toCSV(data, filename, options);
            }
        } catch (error) {
            console.error('Excel export failed:', error);
            return false;
        }
    }
    
    /**
     * Export using SheetJS (XLSX) library
     * @private
     * @param {Array} data - Data to export
     * @param {string} filename - Filename
     * @param {object} options - Export options
     * @returns {boolean} Success status
     */
    toExcelWithXLSX(data, filename, options) {
        try {
            const worksheet = XLSX.utils.json_to_sheet(data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, options.sheetName || 'Data');
            
            // Add metadata sheet if requested
            if (options.includeMetadata) {
                const metadata = {
                    'Export Date': new Date().toISOString(),
                    'Record Count': data.length,
                    'Generated By': 'TenderIntel Platform'
                };
                const metaSheet = XLSX.utils.json_to_sheet([metadata]);
                XLSX.utils.book_append_sheet(workbook, metaSheet, 'Metadata');
            }
            
            XLSX.writeFile(workbook, `${filename}.xlsx`);
            this.addToHistory('Excel', filename, data.length);
            return true;
            
        } catch (error) {
            console.error('XLSX export failed:', error);
            return false;
        }
    }
    
    /**
     * Export to PDF format
     * Requires jsPDF library
     * @param {Array} data - Data to export
     * @param {string} filename - Filename
     * @param {object} options - Export options
     * @returns {boolean} Success status
     */
    toPDF(data, filename = 'export', options = {}) {
        try {
            if (typeof jsPDF === 'undefined') {
                console.error('jsPDF library not loaded');
                return false;
            }
            
            const doc = new jsPDF(options.orientation || 'portrait');
            
            // Add title
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            doc.text(options.title || 'TenderIntel Report', 15, 15);
            
            // Add metadata
            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`Generated: ${window.formatters?.date(new Date().toISOString()) || new Date().toLocaleString()}`, 15, 25);
            
            if (options.subtitle) {
                doc.text(options.subtitle, 15, 32);
            }
            
            // Add table if data is array of objects
            if (Array.isArray(data) && data.length > 0 && typeof doc.autoTable === 'function') {
                const headers = Object.keys(data[0]);
                const rows = data.map(obj => headers.map(key => {
                    const val = obj[key];
                    return val !== null && val !== undefined ? String(val) : '';
                }));
                
                doc.autoTable({
                    startY: options.subtitle ? 40 : 35,
                    head: [headers],
                    body: rows,
                    styles: { fontSize: 8 },
                    headStyles: { fillColor: [37, 99, 235], textColor: 255 },
                    alternateRowStyles: { fillColor: [249, 250, 251] },
                    margin: { top: 10 }
                });
            }
            
            // Save PDF
            doc.save(`${filename}.pdf`);
            this.addToHistory('PDF', filename, data.length);
            return true;
            
        } catch (error) {
            console.error('PDF export failed:', error);
            return false;
        }
    }
    
    /**
     * Convert data array to CSV string
     * @private
     * @param {Array} data - Data to convert
     * @param {object} options - Conversion options
     * @returns {string} CSV string
     */
    convertToCSV(data, options = {}) {
        if (!Array.isArray(data) || data.length === 0) {
            throw new Error('Data must be non-empty array');
        }
        
        const headers = options.headers || Object.keys(data[0]);
        const delimiter = options.delimiter || ',';
        const linebreak = options.linebreak || '\n';
        
        // Build header row
        let csv = headers.map(h => this.escapeCSVValue(h)).join(delimiter) + linebreak;
        
        // Build data rows
        data.forEach(row => {
            const values = headers.map(header => {
                const value = row[header];
                return this.escapeCSVValue(value);
            });
            csv += values.join(delimiter) + linebreak;
        });
        
        return csv;
    }
    
    /**
     * Escape CSV value properly
     * @private
     * @param {any} value - Value to escape
     * @returns {string} Escaped value
     */
    escapeCSVValue(value) {
        if (value === null || value === undefined) return '';
        
        const stringValue = String(value);
        
        // Check if value needs quoting (contains delimiter, quotes, or newlines)
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n') || stringValue.includes('\r')) {
            // Escape quotes by doubling them and wrap in quotes
            return '"' + stringValue.replace(/"/g, '""') + '"';
        }
        
        return stringValue;
    }
    
    /**
     * Download file to user's computer
     * @private
     * @param {string} content - File content
     * @param {string} filename - Filename with extension
     * @param {string} mimeType - MIME type
     */
    downloadFile(content, filename, mimeType) {
        // Create blob with UTF-8 BOM for Excel compatibility
        const BOM = '\uFEFF';
        const blob = new Blob([BOM + content], { type: mimeType });
        const url = window.URL.createObjectURL(blob);
        
        // Create temporary download link
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        
        // Trigger download
        document.body.appendChild(a);
        a.click();
        
        // Cleanup
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 100);
    }
    
    /**
     * Export heatmap data with special formatting
     * @param {object} matrix - Heatmap matrix data
     * @param {Array} firms - Array of firm names
     * @param {Array} services - Array of service names
     * @param {string} metric - Metric name
     * @param {string} filename - Filename
     * @returns {boolean} Success status
     */
    exportHeatmap(matrix, firms, services, metric, filename = 'heatmap') {
        try {
            const data = [];
            
            // Header row
            const header = { firm: 'Firm' };
            services.forEach(service => {
                header[service] = window.formatters?.titleCase(service) || service;
            });
            header.total = 'Total';
            data.push(header);
            
            // Firm rows
            firms.forEach(firm => {
                const row = { firm };
                let firmTotal = 0;
                
                services.forEach(service => {
                    const value = matrix[firm]?.[service] || 0;
                    row[service] = value;
                    firmTotal += value;
                });
                
                row.total = firmTotal;
                data.push(row);
            });
            
            // Totals row
            const totalsRow = { firm: 'TOTAL' };
            services.forEach(service => {
                let serviceTotal = 0;
                firms.forEach(firm => {
                    serviceTotal += matrix[firm]?.[service] || 0;
                });
                totalsRow[service] = serviceTotal;
            });
            
            // Calculate grand total
            let grandTotal = 0;
            firms.forEach(firm => {
                services.forEach(service => {
                    grandTotal += matrix[firm]?.[service] || 0;
                });
            });
            totalsRow.total = grandTotal;
            
            data.push(totalsRow);
            
            return this.toCSV(data, `${filename}_${metric}_${Date.now()}`);
            
        } catch (error) {
            console.error('Heatmap export failed:', error);
            return false;
        }
    }
    
    /**
     * Export search results
     * @param {Array} results - Search results array
     * @param {string} filename - Filename
     * @returns {boolean} Success status
     */
    exportSearchResults(results, filename = 'search_results') {
        try {
            const exportData = results.map(result => ({
                Title: result.title || '',
                Organization: result.org || '',
                Status: result.status || '',
                'AOC Date': result.aoc_date || '',
                'Tender ID': result.tender_id || '',
                'Similarity %': result.similarity_percent || result.score || 0,
                URL: result.url || ''
            }));
            
            return this.toCSV(exportData, `${filename}_${Date.now()}`);
            
        } catch (error) {
            console.error('Search results export failed:', error);
            return false;
        }
    }
    
    /**
     * Export dashboard data
     * @param {object} dashboardData - Dashboard data object
     * @param {string} filename - Filename
     * @returns {boolean} Success status
     */
    exportDashboard(dashboardData, filename = 'dashboard') {
        try {
            const data = [];
            
            // KPI section
            data.push({ Section: 'Key Performance Indicators', Value: '', Unit: '' });
            data.push({ 
                Section: 'Total Market Value', 
                Value: dashboardData.total_market_value_inr || 0, 
                Unit: 'INR' 
            });
            data.push({ 
                Section: 'Total Firms', 
                Value: dashboardData.total_firms || 0, 
                Unit: 'Count' 
            });
            data.push({ 
                Section: 'Market Concentration HHI', 
                Value: dashboardData.market_concentration_hhi || 0, 
                Unit: 'Index' 
            });
            data.push({ 
                Section: 'Average Deal Size', 
                Value: dashboardData.avg_deal_size_inr || 0, 
                Unit: 'INR' 
            });
            data.push({ Section: '', Value: '', Unit: '' }); // Empty row
            
            // Service breakdown section
            data.push({ Section: 'Service Breakdown', Value: '', Unit: '' });
            if (dashboardData.service_breakdown) {
                dashboardData.service_breakdown.forEach(service => {
                    data.push({
                        Section: window.formatters?.titleCase(service.name) || service.name,
                        Value: service.total_value || 0,
                        Unit: 'INR'
                    });
                });
            }
            
            return this.toCSV(data, `${filename}_${Date.now()}`);
            
        } catch (error) {
            console.error('Dashboard export failed:', error);
            return false;
        }
    }
    
    /**
     * Export firm scorecard data
     * @param {object} scorecardData - Firm scorecard data
     * @param {string} firmName - Firm name
     * @returns {boolean} Success status
     */
    exportFirmScorecard(scorecardData, firmName) {
        try {
            const data = [];
            
            // Header
            data.push({ 
                Metric: `Firm Scorecard - ${firmName}`, 
                Value: '', 
                Change: '' 
            });
            data.push({ Metric: '', Value: '', Change: '' });
            
            // Portfolio metrics
            if (scorecardData.portfolio_metrics) {
                const metrics = scorecardData.portfolio_metrics;
                data.push({ Metric: 'Total Contracts', Value: metrics.total_contracts || 0, Change: '' });
                data.push({ Metric: 'Total Value (INR)', Value: metrics.total_value_inr || 0, Change: '' });
                data.push({ Metric: 'Average Deal Size (INR)', Value: metrics.avg_deal_size_inr || 0, Change: '' });
                data.push({ Metric: 'Market Share %', Value: metrics.market_share_percent || 0, Change: '' });
                data.push({ Metric: 'Win Rate %', Value: metrics.win_rate_percent || 0, Change: '' });
                data.push({ Metric: 'Growth Rate %', Value: metrics.growth_rate_percent || 0, Change: '' });
            }
            
            data.push({ Metric: '', Value: '', Change: '' });
            
            // Service distribution
            if (scorecardData.service_distribution) {
                data.push({ Metric: 'Service Distribution', Value: '', Change: '' });
                scorecardData.service_distribution.forEach(service => {
                    data.push({
                        Metric: window.formatters?.titleCase(service.service) || service.service,
                        Value: service.value || 0,
                        Change: `${service.share_percent || 0}%`
                    });
                });
            }
            
            return this.toCSV(data, `scorecard_${firmName.replace(/\s+/g, '_')}_${Date.now()}`);
            
        } catch (error) {
            console.error('Scorecard export failed:', error);
            return false;
        }
    }
    
    /**
     * Export geographic data
     * @param {Array} geographicData - Geographic data array
     * @param {string} filename - Filename
     * @returns {boolean} Success status
     */
    exportGeographicData(geographicData, filename = 'geographic_data') {
        try {
            const exportData = geographicData.map(state => ({
                'State': state.state_name || '',
                'State Code': state.state_code || '',
                'Procurement Density': state.procurement_density || 0,
                'Total Tenders': state.total_tenders || 0,
                'Total Value (INR)': state.total_value_inr || 0,
                'Top Categories': window.formatters?.list(state.top_categories) || '',
                'Latitude': state.coordinates?.[0] || '',
                'Longitude': state.coordinates?.[1] || ''
            }));
            
            return this.toCSV(exportData, `${filename}_${Date.now()}`);
            
        } catch (error) {
            console.error('Geographic data export failed:', error);
            return false;
        }
    }
    
    /**
     * Export market analysis data
     * @param {object} analysisData - Market analysis data
     * @param {string} category - Service category
     * @returns {boolean} Success status
     */
    exportMarketAnalysis(analysisData, category) {
        try {
            const data = [];
            
            // Market overview
            data.push({ Metric: `Market Analysis - ${window.formatters?.titleCase(category) || category}`, Value: '', Unit: '' });
            data.push({ Metric: '', Value: '', Unit: '' });
            
            if (analysisData.market_overview) {
                const overview = analysisData.market_overview;
                data.push({ Metric: 'Total Value', Value: overview.total_value_inr || 0, Unit: 'INR' });
                data.push({ Metric: 'Total Contracts', Value: overview.total_contracts || 0, Unit: 'Count' });
                data.push({ Metric: 'Average Deal Size', Value: overview.avg_deal_size_inr || 0, Unit: 'INR' });
                data.push({ Metric: 'Market Share', Value: overview.market_share_percent || 0, Unit: '%' });
                data.push({ Metric: 'Growth Rate', Value: overview.growth_rate_percent || 0, Unit: '%' });
            }
            
            data.push({ Metric: '', Value: '', Unit: '' });
            
            // Concentration analysis
            if (analysisData.concentration_analysis) {
                data.push({ Metric: 'Concentration Analysis', Value: '', Unit: '' });
                const concentration = analysisData.concentration_analysis;
                data.push({ Metric: 'HHI Index', Value: concentration.hhi_index || 0, Unit: 'Index' });
                data.push({ Metric: 'Market Structure', Value: concentration.market_structure || '', Unit: '' });
                data.push({ Metric: 'Top 3 Share', Value: concentration.top_3_share_percent || 0, Unit: '%' });
                data.push({ Metric: 'Top 5 Share', Value: concentration.top_5_share_percent || 0, Unit: '%' });
            }
            
            data.push({ Metric: '', Value: '', Unit: '' });
            
            // Competitor landscape
            if (analysisData.competitor_landscape) {
                data.push({ Metric: 'Top Competitors', Value: '', Unit: '' });
                analysisData.competitor_landscape.forEach(comp => {
                    data.push({
                        Metric: `${comp.rank}. ${comp.firm_name}`,
                        Value: comp.market_share_percent || 0,
                        Unit: '%'
                    });
                });
            }
            
            return this.toCSV(data, `market_analysis_${category}_${Date.now()}`);
            
        } catch (error) {
            console.error('Market analysis export failed:', error);
            return false;
        }
    }
    
    /**
     * Add export to history
     * @private
     * @param {string} format - Export format
     * @param {string} filename - Filename
     * @param {number} recordCount - Number of records exported
     */
    addToHistory(format, filename, recordCount) {
        this.exportHistory.unshift({
            format,
            filename,
            recordCount,
            timestamp: new Date().toISOString()
        });
        
        // Keep last N exports
        if (this.exportHistory.length > this.maxHistorySize) {
            this.exportHistory = this.exportHistory.slice(0, this.maxHistorySize);
        }
    }
    
    /**
     * Get export history
     * @returns {Array} Export history
     */
    getHistory() {
        return [...this.exportHistory];
    }
    
    /**
     * Clear export history
     */
    clearHistory() {
        this.exportHistory = [];
    }
    
    /**
     * Print current page
     * Opens browser print dialog
     */
    printPage() {
        window.print();
    }
    
    /**
     * Copy data to clipboard
     * @param {string} text - Text to copy
     * @returns {Promise<boolean>} Success status
     */
    async copyToClipboard(text) {
        try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(text);
                return true;
            } else {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);
                return success;
            }
        } catch (error) {
            console.error('Clipboard copy failed:', error);
            return false;
        }
    }
}

// Initialize global export service
window.exportService = new ExportService();

console.log('✅ TenderIntel Export Service loaded successfully');
